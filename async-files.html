<template>
</template>
<script>
(function() {
    'use strict';
    // Creates an object based in the HTML Element prototype
    var prefix = 'async_', sufix = '_file';
    var newElements = document.createDocumentFragment();
    // var style = document.createDocumentFragment();
    var doc = (document._currentScript || document.currentScript).ownerDocument;
    var asyncFiles = Object.create(HTMLElement.prototype);

    // Fires when an instance of the element is created
    asyncFiles.createdCallback = function() {
      // Select the template element
      var template = doc.querySelector('template');
      // Clone the content
      var content = template.content.cloneNode(true);
      this.shadow = this.createShadowRoot();
      this.shadow.appendChild(content);
    };

    asyncFiles.getId = function(file) {
      var basename = file.lastIndexOf('/') + 1;
      var id = file.substring(basename, file.indexOf('.', basename));
      return id;
    };

    asyncFiles.loadFiles = function(files) {
      var head = document.getElementsByTagName('head')[0];
      Object.keys(files).forEach(function(elem) {
        files[elem].forEach(function(file) {
          var id = this.getId(file);
          if(document.getElementById(id)){return;}
          if(elem === 'css') {
            this.loadCss(id, file);
          }else {
            this.loadJs(id, file);
          }
        }.bind(this));
      }.bind(this));
      head.appendChild(newElements);
    };


    asyncFiles.loadJs = function(id, file) {
      if (!window.localStorage || !window.XMLHttpRequest) {
        var js = document.createElement('script');
        js.src = file;
        js.defer = true;
        js.type = 'text/javascript';
        js.id = id;
        newElements.appendChild(js);
        document.cookie = prefix + id;
        console.log('normal')
      }else{
        if (this.fileIsCached(file)) {
          console.log('cache')
          this.injectRaw(localStorage[prefix + id], 'script', id);
        }else{
          this.getContent(file, 'style', id);
        }
      }

    };

    asyncFiles.loadCss = function(id, file) {
      if (!window.localStorage || !window.XMLHttpRequest) {
        var stylesheet = document.createElement('link');
        stylesheet.href = file;
        stylesheet.id = id;
        stylesheet.rel = 'stylesheet';
        stylesheet.type = 'text/css';
        newElements.appendChild(stylesheet);
        document.cookie = prefix + id;
      }else{
        if (this.fileIsCached(file)) {
          this.injectRaw(localStorage[prefix + id], 'style', id);
        }else{
          this.getContent(file, 'style', id);
        }
      }

    };

    asyncFiles.injectRaw = function(text, tag, id){
      var elem = document.createElement(tag);
      elem.innerHTML = text;
      elem.id = id;
      newElements.appendChild(elem);
    };

    asyncFiles.getContent = function(url, type, id) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);
      xhr.onload = function(res){
        console.log('cache + load', res)
        if (xhr.readyState === 4) {
          // once we have the content, quickly inject the css rules
          this.injectRaw(xhr.responseText, type, id);
          // and cache the text content for further use
          // notice that this overwrites anything that might have already been previously cached
          localStorage[prefix + id] = xhr.responseText;
          localStorage[prefix + id + sufix] = url;
        }
      }.bind(this);
      xhr.send();
    };

    asyncFiles.fileIsCached = function(id, href) {
      return window.localStorage && localStorage[prefix + id] &&
      (localStorage[prefix + id + sufix] === href);
    };

    // Fires when an instance was inserted into the document
    asyncFiles.attachedCallback = function() {
      var cssS = JSON.parse(this.getAttribute('css'));
      var jsS = JSON.parse(this.getAttribute('js'));
      var files = {};
      if(cssS && cssS.length){
        files.css = cssS;
      }
      if(jsS && jsS.length){
        files.js = jsS;
      }
      this.loadFiles(files);
    };

    // Fires when an instance was removed from the document
    // asyncFiles.detachedCallback = function() {};

    // Fires when an attribute was added, removed, or updated
    // asyncFiles.attributeChangedCallback = function(attr, oldVal, newVal) {};

    document.registerElement('async-files', {
        prototype: asyncFiles
    });
}());
</script>
